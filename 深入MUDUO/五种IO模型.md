# 五种IO模型

## 1.同步阻塞

数据没就绪主线程阻塞，数据准备好自己将TCP缓冲区数据搬运到自己的应用层buf



## 2.同步非阻塞

数据没就绪主线程不阻塞并返回值若没准备好则要么死等要么轮询都消耗CPU，数据准备好自己将TCP缓冲区数据搬运到自己的应用层buf



## 3.异步

异步基本上只有非阻塞，从对端到内核，从内核用应用层均由OS内核完成，应用层自己弄自己的即可，直到数据准备完成由OS内核通知应用层



## 4.IO复用

这默认是一个同步阻塞IO（可以给这些设置非阻塞），从对端到内核，若内核数据准备好了返回可读的fd，然后应用层等到自己将数据复制到自己的buf之中后才能继续向下执行指令流。





IO复用的优势就在于，它不像read在第一阶段只能监听一个IO，而它（select/poll/epoll)能同时监听多个IO。 

相比于read/write:第一阶段不再用read原生的监听而是用IO复用函数的监听。

## 5.信号驱动

linux特有，这是一个半异步半同步的IO模型，第一阶段是异步，通过注册信号及调用函数告诉内核:如果对端的数据到内核缓存区中准备好了就通过回调函数通知我，而我现在去干别的事。  第二个阶段是同步，当收到通知后，我再去处理将内核缓冲区的数据搬运到我的应用层buf中去，这个是应用层自己去做的。







## 最后注意

同步IO的第二阶段都是阻塞，要等待自己把内核的数据搬运到自己的buf中。