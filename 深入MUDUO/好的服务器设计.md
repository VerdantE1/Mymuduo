# 好的服务器设计

### IO复用为什么要配合非阻塞？

非阻塞单单用纯属是浪费CPU，不多说。



IO复用什么要配合非阻塞呢？

拿epoll举例，如果epoll中某个事件得到响应，那我们开始处理对应的socket，如果该socket是阻塞的，假如该socket有数据，那么我们将socket数据读完后写到数据中，那么此时socket没有数据因为socket是阻塞的，那么由于该socket上没有数据所以触发了主流程阻塞，导致无法再回到epoll_wait（）,这就相当于只处理了一个socket。所以这是不可取的。



就比如

```c
while(1){
	epoll_wait();
//ok,若内核准备好了即有socket可以读，那么第一阶段结束。
//开始第二阶段
	while((recv(sockfd,buf,SZ)) > 0 ); //因为一次不一定能够全部读完所以用while
    
//将数据读完后，如果sockfd是阻塞的，那么recv就会一直阻塞就再也返回不了epoll_wait()了，如果sockfd是非阻塞的那么就直接返回。
    
//而如果是非阻塞则返回-1，则直接跳出while，进行下一次epoll_wait()
}

```



 **一个好的服务器设计都是one loop per thread ： `non_blockin && IO_multiplexing(epoll) + 线程池`一起使用。**





### 当然也有其他的服务器采用其他的方法

##### nginx

比如nginx采用epoll+fork模型

强大的nginx服务器采用了epoll+fork模型作为网络模块的架构设计，实现了简单好用的负载算法，使各个fork网络进程不会忙的越忙、闲的越闲，并且通过引入一把乐观锁解决了该模型导致的**服务器惊群**现象，功能十分强大。
